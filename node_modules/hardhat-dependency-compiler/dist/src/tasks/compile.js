"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const package_json_1 = require("../../package.json");
const fs_1 = __importDefault(require("fs"));
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const path_1 = __importDefault(require("path"));
const generate = function (dependency) {
    return [
        '// SPDX-License-Identifier: UNLICENSED',
        'pragma solidity >0.0.0;',
        `import '${dependency}';`,
    ]
        .map((l) => `${l}\n`)
        .join('');
};
(0, config_1.task)(task_names_1.TASK_COMPILE, async function (args, hre, runSuper) {
    const config = hre.config.dependencyCompiler;
    // other packages may incorrectly set a relative sources path so it must be explicitly resolved
    const sources = path_1.default.resolve(hre.config.paths.sources);
    const directory = path_1.default.resolve(sources, config.path);
    const tracker = path_1.default.resolve(directory, `.${package_json_1.name}`);
    if (!fs_1.default.existsSync(sources)) {
        fs_1.default.mkdirSync(sources);
    }
    if (!directory.startsWith(sources)) {
        throw new plugins_1.HardhatPluginError(package_json_1.name, 'resolved path must be inside of sources directory');
    }
    if (directory === sources) {
        throw new plugins_1.HardhatPluginError(package_json_1.name, 'resolved path must not be sources directory');
    }
    if (fs_1.default.existsSync(directory)) {
        // delete directory only if tracker is found or directory is empty
        if (fs_1.default.existsSync(tracker) || fs_1.default.readdirSync(directory).length == 0) {
            fs_1.default.rmSync(directory, { recursive: true });
        }
        else {
            throw new plugins_1.HardhatPluginError(package_json_1.name, `temporary source directory must have been generated by ${package_json_1.name}`);
        }
    }
    fs_1.default.mkdirSync(directory);
    fs_1.default.writeFileSync(tracker, `directory approved for write access by ${package_json_1.name}\n`);
    for (let dependency of config.paths) {
        const fullPath = path_1.default.join(directory, dependency);
        if (!fs_1.default.existsSync(path_1.default.dirname(fullPath))) {
            fs_1.default.mkdirSync(path_1.default.dirname(fullPath), { recursive: true });
        }
        fs_1.default.writeFileSync(fullPath, generate(dependency));
    }
    try {
        await runSuper();
    }
    finally {
        if (!config.keep) {
            fs_1.default.rmSync(directory, { recursive: true });
        }
    }
});
